{"name":"Afterparty","tagline":"A Rails 4 compatible queue with support for executing jobs in the future and persistence with ActiveRecord.","body":"# Afterparty\r\n\r\n[![Build Status](https://travis-ci.org/hstove/afterparty.png?branch=master)](https://travis-ci.org/hstove/afterparty)\r\n\r\nA Rails 3 & 4 compatible queue with support for executing jobs in the future and persistence with ActiveRecord.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n~~~Ruby\r\ngem 'afterparty'\r\n~~~\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n    $ rails g afterparty\r\n    $ rake db:migrate\r\n\r\nThis will create an initializer in `config/initializers/afterparty.rb`. It initializes a queue at\r\n`Rails.configuration.queue` for you to pass jobs to.\r\n\r\n## Usage\r\n\r\nA `job` is a ruby object with a `run` method.\r\n\r\n~~~Ruby\r\nclass Job\r\n  def run\r\n    puts \"Hello!\"\r\n  end\r\nend\r\n~~~\r\n\r\nThen add it to the queue at any time.\r\n\r\n~~~Ruby\r\nRails.configuration.queue << Job.new\r\n~~~\r\n\r\nIf your job responds to an `execute_at` method, the queue will wait to process that job until the specified time.\r\n\r\n### Running jobs\r\n\r\nYou can start a worker in a separate process for executing jobs by calling `rake jobs:work`.\r\n\r\n### Helper jobs\r\n\r\nAfterparty provides helper job wrappers for executing arbitrary methods or mailers.\r\n\r\n~~~Ruby\r\n# pass an object, method, and arguments \r\n\r\nmailer_job = Afterparty::MailerJob.new UserMailer, :welcome, @user\r\nmailer_job.execute_at = Time.now + 20.minutes\r\nRails.configuration.queue << mailer_job\r\n\r\njob = Afterparty::BasicJob.new @user, :reset_password\r\nRails.configuration.queue << job\r\n~~~\r\n\r\n### Dashboard\r\n\r\n![dashboard screenshot](https://raw.github.com/hstove/afterparty/master/docs/dashboard.png)\r\n\r\nThis gem provides a handy dashboard for inspecting, debugging, and re-running jobs.\r\n\r\nVisit [http://localhost:3000/afterparty/](http://localhost:3000/afterparty/) and login with\r\n`admin` and `password`. You can change the authentication strategy in `config/initializers/afterparty.rb` to something like this:\r\n\r\n~~~Ruby\r\nRails.configuration.queue.config_login do |username, password|\r\n  user = User.authenticate(username, password)\r\n  !user.nil? && user.is_admin?\r\nend\r\n~~~\r\n\r\n### Unicorn configuration\r\n\r\nIf you're using Unicorn as your application server, you can run a worker thread asynchronously by adding a few lines to your `unicorn.rb`:\r\n\r\n~~~Ruby\r\n\r\n@jobs_pid = nil\r\n\r\nbefore_fork do |server, worker|\r\n  @jobs_pid ||= spawn(\"bundle exec rake jobs:work\")\r\n\r\n  # ... the rest of your configuration\r\n~~~\r\n\r\nThis has the advantage of, for example, staying within Heroku's free tier by not running a worker dyno.\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Add a test in `spec/redis_queue_spec.rb`\r\n4. Make sure tests pass when you run `rake`\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"UA-40884880-1","note":"Don't delete this file! It's used internally to help with page regeneration."}